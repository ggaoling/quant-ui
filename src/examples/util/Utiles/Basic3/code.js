const code = `
<pre class="prettyprint linenums prettyprinted" data-anchor-id="rzui" style=""><ol class="linenums"><li class="L0"><code><span class="com">/**</span></code></li><li class="L1"><code><span class="com"> * @desc   函数节流。</span></code></li><li class="L2"><code><span class="com"> * 适用于限制'resize'和'scroll'等函数的调用频率</span></code></li><li class="L3"><code><span class="com"> *</span></code></li><li class="L4"><code><span class="com"> * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。</span></code></li><li class="L5"><code><span class="com"> * @param  {Boolean}   noTrailing     可选，默认为false。</span></code></li><li class="L6"><code><span class="com"> *                                    如果noTrailing为true，当节流函数被调用，每过'delay'毫秒'callback'也将执行一次。</span></code></li><li class="L7"><code><span class="com"> *                                    如果noTrailing为false或者未传入，'callback'将在最后一次调用节流函数后再执行一次.</span></code></li><li class="L8"><code><span class="com"> *                                    （延迟'delay'毫秒之后，节流函数没有被调用,内部计数器会复位）</span></code></li><li class="L9"><code><span class="com"> * @param  {Function}  callback       延迟毫秒后执行的函数。'this'上下文和所有参数都是按原样传递的，</span></code></li><li class="L0"><code><span class="com"> *                                    执行去节流功能时，调用'callback'。</span></code></li><li class="L1"><code><span class="com"> * @param  {Boolean}   debounceMode   如果'debounceMode'为true，'clear'在'delay'ms后执行。</span></code></li><li class="L2"><code><span class="com"> *                                    如果debounceMode是false，'callback'在'delay' ms之后执行。</span></code></li><li class="L3"><code><span class="com"> *</span></code></li><li class="L4"><code><span class="com"> * @return {Function}  新的节流函数</span></code></li><li class="L5"><code><span class="com"> */</span></code></li><li class="L6"><code><span class="kwd">module</span><span class="pun">.</span><span class="pln">exports </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> throttle</span><span class="pun">(</span><span class="pln">delay</span><span class="pun">,</span><span class="pln"> noTrailing</span><span class="pun">,</span><span class="pln"> callback</span><span class="pun">,</span><span class="pln"> debounceMode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">    </span><span class="com">// After wrapper has stopped being called, this timeout ensures that</span></code></li><li class="L9"><code><span class="pln">    </span><span class="com">// 'callback' is executed at the proper times in 'throttle' and 'end'</span></code></li><li class="L0"><code><span class="pln">    </span><span class="com">// debounce modes.</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> timeoutID</span><span class="pun">;</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">    </span><span class="com">// Keep track of the last time 'callback' was executed.</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">var</span><span class="pln"> lastExec </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code></code></li><li class="L6"><code><span class="pln">    </span><span class="com">// 'noTrailing' defaults to falsy.</span></code></li><li class="L7"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> noTrailing </span><span class="pun">!==</span><span class="pln"> </span><span class="str">'boolean'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code><span class="pln">        debounceMode </span><span class="pun">=</span><span class="pln"> callback</span><span class="pun">;</span></code></li><li class="L9"><code><span class="pln">        callback </span><span class="pun">=</span><span class="pln"> noTrailing</span><span class="pun">;</span></code></li><li class="L0"><code><span class="pln">        noTrailing </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pun">;</span></code></li><li class="L1"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">    </span><span class="com">// The 'wrapper' function encapsulates all of the throttling / debouncing</span></code></li><li class="L4"><code><span class="pln">    </span><span class="com">// functionality and when executed will limit the rate at which 'callback'</span></code></li><li class="L5"><code><span class="pln">    </span><span class="com">// is executed.</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">function</span><span class="pln"> wrapper</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">        </span><span class="kwd">var</span><span class="pln"> </span><span class="kwd">self</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">;</span></code></li><li class="L9"><code><span class="pln">        </span><span class="kwd">var</span><span class="pln"> elapsed </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">())</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> lastExec</span><span class="pun">;</span></code></li><li class="L0"><code><span class="pln">        </span><span class="kwd">var</span><span class="pln"> args </span><span class="pun">=</span><span class="pln"> arguments</span><span class="pun">;</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="pln">        </span><span class="com">// Execute 'callback' and update the 'lastExec' timestamp.</span></code></li><li class="L3"><code><span class="pln">        </span><span class="kwd">function</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code><span class="pln">            lastExec </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">());</span></code></li><li class="L5"><code><span class="pln">            callback</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">,</span><span class="pln"> args</span><span class="pun">);</span></code></li><li class="L6"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">        </span><span class="com">// If 'debounceMode' is true (at begin) this is used to clear the flag</span></code></li><li class="L9"><code><span class="pln">        </span><span class="com">// to allow future 'callback' executions.</span></code></li><li class="L0"><code><span class="pln">        </span><span class="kwd">function</span><span class="pln"> clear</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">            timeoutID </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">debounceMode </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">timeoutID</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code><span class="pln">            </span><span class="com">// Since 'wrapper' is being called for the first time and</span></code></li><li class="L6"><code><span class="pln">            </span><span class="com">// 'debounceMode' is true (at begin), execute 'callback'.</span></code></li><li class="L7"><code><span class="pln">            </span><span class="kwd">exec</span><span class="pun">();</span></code></li><li class="L8"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="pln">        </span><span class="com">// Clear any existing timeout.</span></code></li><li class="L1"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">timeoutID</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">            clearTimeout</span><span class="pun">(</span><span class="pln">timeoutID</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">debounceMode </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> elapsed </span><span class="pun">&gt;</span><span class="pln"> delay</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code><span class="pln">            </span><span class="com">// In throttle mode, if 'delay' time has been exceeded, execute</span></code></li><li class="L7"><code><span class="pln">            </span><span class="com">// 'callback'.</span></code></li><li class="L8"><code><span class="pln">            </span><span class="kwd">exec</span><span class="pun">();</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="pln">        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">noTrailing </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">            </span><span class="com">// In trailing throttle mode, since 'delay' time has not been</span></code></li><li class="L2"><code><span class="pln">            </span><span class="com">// exceeded, schedule 'callback' to execute 'delay' ms after most</span></code></li><li class="L3"><code><span class="pln">            </span><span class="com">// recent execution.</span></code></li><li class="L4"><code><span class="pln">            </span><span class="com">//</span></code></li><li class="L5"><code><span class="pln">            </span><span class="com">// If 'debounceMode' is true (at begin), schedule 'clear' to execute</span></code></li><li class="L6"><code><span class="pln">            </span><span class="com">// after 'delay' ms.</span></code></li><li class="L7"><code><span class="pln">            </span><span class="com">//</span></code></li><li class="L8"><code><span class="pln">            </span><span class="com">// If 'debounceMode' is false (at end), schedule 'callback' to</span></code></li><li class="L9"><code><span class="pln">            </span><span class="com">// execute after 'delay' ms.</span></code></li><li class="L0"><code><span class="pln">            timeoutID </span><span class="pun">=</span><span class="pln"> setTimeout</span><span class="pun">(</span><span class="pln">debounceMode </span><span class="pun">?</span><span class="pln"> clear </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">,</span><span class="pln"> debounceMode </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> delay </span><span class="pun">-</span><span class="pln"> elapsed </span><span class="pun">:</span><span class="pln"> delay</span><span class="pun">);</span></code></li><li class="L1"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">    </span><span class="com">// Return the wrapper function.</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> wrapper</span><span class="pun">;</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pun">};</span></code></li></ol></pre>
`;

export default {
	code,
}